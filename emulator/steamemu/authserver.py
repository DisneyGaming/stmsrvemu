import threading, logging, struct, binascii, time, socket, ipaddress, os.path, ast, random, pprint, datetime

from Crypto.Hash import SHA

import steam
import config
import globalvars

class authserver(threading.Thread):
    def __init__(self, (socket, address), config) :
        threading.Thread.__init__(self)
        self.socket = socket
        self.address = address
        self.config = config

    def run(self):
        log = logging.getLogger("authsrv")

        clientid = str(self.address) + ": "

        log.info(clientid + "Connected to Auth Server")

        command = self.socket.recv(13)
        
        log.debug(":" + binascii.b2a_hex(command[1:5]) + ":")
        log.debug(":" + binascii.b2a_hex(command) + ":")

        if command[1:5] == "\x00\x00\x00\x04" or command[1:5] == "\x00\x00\x00\x01" or command[1:5] == "\x00\x00\x00\x02" or command[1:5] == "\x00\x00\x00\x03" :

            self.socket.send("\x00" + socket.inet_aton(self.address[0]))
            log.debug((str(socket.inet_aton(self.address[0]))))
            log.debug((str(socket.inet_ntoa(socket.inet_aton(self.address[0])))))

            command = self.socket.recv_withlen()

            if len(command) > 1 and len(command) < 256 :
            
                usernamelen = struct.unpack(">H", command[1:3])[0]
                
                userblob = {}

                username = command[3:3 + usernamelen]
                
                #------------ LEGACY ------------
                #if os.path.isfile("files/users.txt") :
                #    users = {} #OLD
                #    f = open("files/users.txt")
                #    for line in f.readlines() :
                #        if line[-1:] == "\n" :
                #            line = line[:-1]
                #        if line.find(":") != -1 :
                #            (user, password) = line.split(":")
                #    #        users[user] = password
                #            users[user] = user
                #    f.close()
                #    #example: 020005746573743100057465737431 (test1)
                #    #02 = padding
                #    for user in users :
                #        if (os.path.isfile("files/users/" + username + ".py")) :
                #            os.rename("files/users/" + username + ".py", "files/users/" + username + ".legacy")
                #    os.rename("files/users.txt", "files/users.off")
                #------------ LEGACY ------------
                #print "user:" + username + ":"
                log.info(clientid + "Processing logon for user: " + username) # 7465737431
                log.debug(clientid + "Username length: " + str(usernamelen)) # 0005
                #username length and username is then received again
                #legacyuser = 0
                #legacyblocked = 0
                #try :
                #    users[username]
                #    legacyuser = 1
                #    if users[username] == "blocked" :
                #        legacyblocked = 1
                #    else :
                #        legacyblocked = 0
                #except :
                #    legacyuser = 0
                
                if (os.path.isfile("files/users/" + username + ".py")) :#and legacyuser == 0 :
                    with open("files/users/" + username + ".py", 'r') as f:
                        userblobstr = f.read()
                        userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    #print(userblob)
                    blocked = binascii.b2a_hex(userblob['\x0c\x00\x00\x00'])
                    if blocked == "0001" :
                        log.info(clientid + "Blocked user: " + username)
                        self.socket.send("\x00\x00\x00\x00\x00\x00\x00\x00")
                        command = self.socket.recv_withlen()
                        steamtime = steam.unixtime_to_steamtime(time.time())
                        tgt_command = "\x04" #BLOCKED
                        padding = "\x00" * 1222
                        ticket_full = tgt_command + steamtime + padding
                        self.socket.send(ticket_full)
                    else :
                        personalsalt = userblob['\x05\x00\x00\x00'][username]['\x02\x00\x00\x00']
                        #print(personalsalt)
                        self.socket.send(personalsalt) #NEW SALT PER USER
                        command = self.socket.recv_withlen()
                        key = userblob['\x05\x00\x00\x00'][username]['\x01\x00\x00\x00'][0:16] #password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
                        #print(binascii.b2a_hex(key))
                        IV = command[0:16]
                        #print(binascii.b2a_hex(IV))
                        encrypted = command[20:36]
                        #print(binascii.b2a_hex(encrypted))
                        decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, IV, encrypted))
                        log.debug(clientid + "Authentication package: " + decodedmessage)
                
                        if not decodedmessage.endswith("04040404") :
                            wrongpass = "1"
                            log.info(clientid + "Incorrect password entered for: " + username)
                        else :
                            wrongpass = "0"                
                
                        # create login ticket
                        execdict = {}
                        execdict_new = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        secretkey = {'\x05\x00\x00\x00'}
                        def without_keys(d, keys) :
                            return {x: d[x] for x in d if x not in keys}
                        execdict_new = without_keys(execdict, secretkey)
                        #print(execdict)
                        #print(execdict_new)
                        blob = steam.blob_serialize(execdict_new)
                        #print(blob)
                        bloblen = len(blob)
                        log.debug("Blob length: " + str(bloblen))
                        innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                        blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                        blob_signature = steam.sign_message(innerkey, blob_encrypted)
                        blob_encrypted_len = 10 + len(blob_encrypted) + 20
                        blob_encrypted = struct.pack(">L", blob_encrypted_len) + "\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
                        currtime = time.time()
                        outerIV = binascii.a2b_hex("92183129534234231231312123123353")
                        #steamid = binascii.a2b_hex("0000" + "80808000" + "00000000")
                        steamUniverse = "0000"
                        steamid = binascii.a2b_hex(steamUniverse + binascii.b2a_hex(userblob['\x06\x00\x00\x00'][username]['\x01\x00\x00\x00'][0:16]))
                        #servers = binascii.a2b_hex("451ca0939a69451ca0949a69")
                        #authport = struct.pack("<L", int(port))
                        if self.config["public_ip"] != "0.0.0.0" :
                            bin_ip = steam.encodeIP((self.config["public_ip"], self.config["validation_port"]))
                        else :
                            bin_ip = steam.encodeIP((self.config["server_ip"], self.config["validation_port"]))
                        #bin_ip = steam.encodeIP(("172.21.0.20", "27039"))
                        servers = bin_ip + bin_ip
                        times = steam.unixtime_to_steamtime(currtime) + steam.unixtime_to_steamtime(currtime + (60*60*24*28))
                        subheader = innerkey + steamid + servers + times
                        subheader_encrypted = steam.aes_encrypt(key, outerIV, subheader)
                        subhead_decr_len = "\x00\x36"
                        subhead_encr_len = "\x00\x40"
                        if globalvars.tgt_version == "1" : #nullData1
                            subheader_encrypted = "\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted #TTicket_SubHeader (EncrData)
                            log.debug(clientid + "TGT Version: 1") #v2 Steam
                        elif globalvars.tgt_version == "2" :
                            subheader_encrypted = "\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
                            log.debug(clientid + "TGT Version: 2") #v3 Steam
                        else :
                            subheader_encrypted = "\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
                            log.debug(clientid + "TGT Version: 2") #Assume v3 Steam
                        #unknown_part = "\x01\x68" + ("\xff" * 0x168) #THE ACTUAL TICKET!!!
                        #0 = eVersionNum
                        #1=eUniqueAccountName
                        #2=eAccountUserName
                        #3=eSteamInstanceID
                        #4=eSteamLocalUserID
                        #5=eClientExternalIPAddr
                        #6=eClientLocalIPAddr
                        #7=eUserIDTicketValidationServerIPAddr1
                        #8=eUserIDTicketValidationServerport1
                        #9=eUserIDTicketValidationServerIPAddr2
                        #10=eUserIDTicketValidationServerport2
                        #11=eClientToServerAESSessionKey
                        #12=eTicketCreationTime
                        #13=TicketValidUntilTime
                        #14=ServerReadablePart
                        clientIP = socket.inet_aton(self.address[0])
                        publicIP = clientIP[::-1]
                        #subcommand3 = "\x00\x00\x00\x00"
                        data1_len_str = "\x00\x80"
                        #empty1 = ("\x00" * 0x80) #TTicketHeader unknown encrypted
                        data1 = username + username + "\x00\x01" + publicIP + clientIP + servers + key + times
                        data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
                        data1_full = data1 + ("\x00" * (data1_len_empty / 2))
                        empty3 = ("\x00" * 0x80) #unknown encrypted - RSA sig?
                        username_len = len(username)
                        #username_len_packed = struct.pack(">H", 50 + username_len)
                        accountId = userblob['\x06\x00\x00\x00'][username]['\x01\x00\x00\x00'][0:16] #SteamID
                        data2 = struct.pack(">L", len(username))
                        if globalvars.tgt_version == "1" :
                            subcommand1 = "\x00\x01" #for TGT v1
                            subcommand2 = "" #missing for TGT v1
                            empty2_dec_len = "\x00\x42"
                            empty2_enc_len = "\x00\x50"
                            #empty2 = ("\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
                            data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
                            data2_full = data2 + ("\x00" * (data2_len_empty / 2))
                        elif globalvars.tgt_version == "2" :
                            subcommand1 = "\x00\x02" #for TGT v2
                            subcommand2 = "\x00\x10" #steamID+clientIPaddress TGT v2 only
                            subcommand2 = subcommand2 + accountId + clientIP
                            empty2_dec_len = "\x00\x52"
                            empty2_enc_len = "\x00\x60"
                            #empty2 = ("\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
                            data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
                            data2_full = data2 + ("\x00" * (data2_len_empty / 2))
                        else :
                            subcommand1 = "\x00\x02" #assume TGT v2
                            subcommand2 = "\x00\x10" #steamID+clientIPaddress TGT v2 only
                            subcommand2 = subcommand2 + accountId + clientIP
                            empty2_dec_len = "\x00\x52"
                            empty2_enc_len = "\x00\x60"
                            #empty2 = ("\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
                            data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
                            data2_full = data2 + ("\x00" * (data2_len_empty / 2))
                        
                        #empty2 = username + empty2_empty[(len(username)):]
                        real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
                        real_ticket_len = struct.pack(">H", len(real_ticket)) #TicketLen
                        #ticket = subheader_encrypted + unknown_part + blob_encrypted
                        ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted
                        
                        ticket_signed = ticket + steam.sign_message(innerkey, ticket)
                        
                        #tgt_command = "\x03" #Clock-skew too far out
                        if wrongpass == "1" :
                            tgt_command = "\x02" #Incorrect password
                        else :
                            tgt_command = "\x00" #Authenticated # AuthenticateAndRequestTGT command
                        steamtime = steam.unixtime_to_steamtime(time.time())
                        clock_skew_tolerance = "\x00\xd2\x49\x6b\x00\x00\x00\x00"
                        authenticate = tgt_command + steamtime + clock_skew_tolerance
                        writeAccountInformation = struct.pack(">L", len(ticket_signed)) + ticket_signed #FULL TICKET (steamticket.bin)
                        self.socket.send(authenticate + writeAccountInformation)
                        
                #elif legacyblocked == 1 :
                #    log.warning(clientid + "Blocked legacy user: " + username)
                #    self.socket.send("\x00\x00\x00\x00\x00\x00\x00\x00")
                #    steamtime = steam.unixtime_to_steamtime(time.time())
                #    tgt_command = "\x04" #BLOCKED
                #    padding = "\x00" * 1222
                #    ticket_full = tgt_command + steamtime + padding
                #    self.socket.send(ticket_full)
                    
                #elif legacyuser == 1 :
                #    log.warning("Legacy user: " + username)
                
                #    self.socket.send("\x01\x23\x45\x67\x89\xab\xcd\xef") # salt - OLD
                #    command = self.socket.recv_withlen()

                #    key = SHA.new("\x01\x23\x45\x67" + users[username] + "\x89\xab\xcd\xef").digest()[:16]
                #    #print(binascii.b2a_hex(key))
                #    IV = command[0:16]
                #    #print(binascii.b2a_hex(IV))
                #    encrypted = command[20:36]
                #    #print(binascii.b2a_hex(encrypted))
                #    decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, IV, encrypted))
                #    log.debug(clientid + "Decoded message: " + decodedmessage)
                
                #    if not decodedmessage.endswith("04040404") :
                #        wrongpass = "1"
                #        log.info(clientid + "Incorrect password entered for: " + username)
                #        #wrongpass = "0"  
                #    else :
                #        wrongpass = "0"                
                
                #    # create login ticket
                #    execdict = {}
                #    execdict_new = {}
                #    #execfile("files/users/%s.py" % username, execdict)
                #    with open("files/users/" + username + ".py", 'r') as f:
                #        userblobstr = f.read()
                #        execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                #    #blob = steam.blob_serialize(execdict["user_registry"])
                #    secretkey = {'\x05\x00\x00\x00'}
                #    def without_keys(d, keys) :
                #        return {x: d[x] for x in d if x not in keys}
                #    execdict_new = without_keys(execdict, secretkey)
                #    blob = steam.blob_serialize(execdict_new)
                #    bloblen = len(blob)
                #    log.debug("Blob length: " + str(bloblen))
                #    innerkey = binascii.a2b_hex("10231230211281239191238542314233")
                #    innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344")
                #    blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                #    blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                #    blob_signature = steam.sign_message(innerkey, blob_encrypted)
                #    blob_encrypted_len = 10 + len(blob_encrypted) + 20
                #    blob_encrypted = struct.pack(">L", blob_encrypted_len) + "\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
                #    currtime = time.time()
                #    outerIV = binascii.a2b_hex("92183129534234231231312123123353")
                #    steamid = binascii.a2b_hex("0000" + "80808000" + "00000000")
                #    #steamid = binascii.a2b_hex("0000" + "0b000000" + "00000000")
                #    #servers = binascii.a2b_hex("451ca0939a69451ca0949a69")
                #    bin_ip = steam.encodeIP((self.config["server_ip"], self.config["validation_port"]))
                #    #bin_ip = steam.encodeIP(("172.21.0.20", "27039"))
                #    servers = bin_ip + bin_ip
                #    times = steam.unixtime_to_steamtime(currtime) + steam.unixtime_to_steamtime(currtime + (60*60*24*28))
                #    subheader = innerkey + steamid + servers + times
                #    subheader_encrypted = steam.aes_encrypt(key, outerIV, subheader)
                #    #if self.config["tgt_version"] == "1" :
                #    if globalvars.tgt_version == "1" :
                #        subheader_encrypted = "\x00\x01" + outerIV + "\x00\x36\x00\x40" + subheader_encrypted
                #        log.debug(clientid + "TGT Version: 1") #v2 Steam
                #    #elif self.config["tgt_version"] == "2" :
                #    elif globalvars.tgt_version == "2" :
                #        subheader_encrypted = "\x00\x02" + outerIV + "\x00\x36\x00\x40" + subheader_encrypted
                #        log.debug(clientid + "TGT Version: 2") #v3 Steam
                #    else :
                #        subheader_encrypted = "\x00\x02" + outerIV + "\x00\x36\x00\x40" + subheader_encrypted
                #        log.debug(clientid + "TGT Version: 2")
                #    with open("files/users/" + username + ".py", 'r') as f:
                #        userblobstr = f.read()
                #        userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                #    unknown_part = "\x01\x68" + ("\xff" * 0x168) #THE ACTUAL TICKET!!!
                #    ticket = subheader_encrypted + unknown_part + blob_encrypted
                #    ticket_signed = ticket + steam.sign_message(innerkey, ticket)
                #    if wrongpass == "1" :
                #        tgt_command = "\x02"
                #    else :
                #        tgt_command = "\x00" # AuthenticateAndRequestTGT command
                #    steamtime = steam.unixtime_to_steamtime(time.time())
                #    ticket_full = tgt_command + steamtime + "\x00\xd2\x49\x6b\x00\x00\x00\x00" + struct.pack(">L", len(ticket_signed)) + ticket_signed
                #    self.socket.send(ticket_full)
                    
                else :
                    log.info(clientid + "Unknown user: " + username)
                    self.socket.send("\x00\x00\x00\x00\x00\x00\x00\x00")
                    steamtime = steam.unixtime_to_steamtime(time.time())
                    tgt_command = "\x01" #UNKNOWN USER
                    padding = "\x00" * 1222
                    ticket_full = tgt_command + steamtime + padding
                    self.socket.send(ticket_full)

            elif len(command) >= 256 :
                #print(binascii.b2a_hex(command[0:3]))
                if binascii.b2a_hex(command[0:1]) == "10" : #Change password
                    #log.info(clientid + "Change password")
                    
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    
                    log.info(clientid + "Password change requested for: " + username)
                    
                    userblob = {}
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    personalsalt = userblob['\x05\x00\x00\x00'][username]['\x02\x00\x00\x00']
                    #print(personalsalt)
                    self.socket.send(personalsalt) #NEW SALT PER USER
                    blobtext = self.socket.recv_withlen()
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    IV = binascii.a2b_hex("12899c8312213a123321321321543344")
                    crypted_blob = blobtext[10:]
                    if repr(steam.verify_message(key, crypted_blob)) :
                        plaintext = steam.aes_decrypt(key, IV, crypted_blob[4:-4])
                        blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
                        blob_len = len(plaintext) - 16 - blob_len
                        blob = steam.blob_unserialize(plaintext[16:-blob_len])
                        #print(blob)
                        #print(binascii.b2a_hex(blob["\x01\x00\x00\x00"]))
                        #print(binascii.b2a_hex(userblob['\x05\x00\x00\x00'][username]['\x01\x00\x00\x00']))
                        if blob["\x01\x00\x00\x00"] == userblob['\x05\x00\x00\x00'][username]['\x01\x00\x00\x00'] :
                            userblob['\x05\x00\x00\x00'][username]['\x01\x00\x00\x00'] = blob["\x03\x00\x00\x00"]
                            userblob['\x05\x00\x00\x00'][username]['\x02\x00\x00\x00'] = blob["\x02\x00\x00\x00"]
                            if (os.path.isfile("files/users/" + username + ".py")) :
                                with open("files/users/" + username + ".py", 'w') as userblobfile :
                                    userblobfile.write("user_registry = ")
                                    userblobfile.write(str(userblob))                              
                                log.info(clientid + "Password changed for: " + username)
                                self.socket.send("\x00")
                            else :
                                log.warn(clientid + "SADB file error for: " + username)
                                self.socket.send("\x01")
                        else :
                            log.warn(clientid + "Password change failed for: " + username)
                            self.socket.send("\x01")
                    else :
                        log.warn(clientid + "Password change failed for: " + username)
                        self.socket.send("\x01")
                elif binascii.b2a_hex(command[0:1]) == "11" : #Change question
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    
                    log.info(clientid + "Secret question change requested for: " + username)
                    
                    userblob = {}
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    personalsalt = userblob['\x05\x00\x00\x00'][username]['\x02\x00\x00\x00']
                    #print(personalsalt)
                    self.socket.send(personalsalt) #NEW SALT PER USER
                    blobtext = self.socket.recv_withlen()
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    IV = binascii.a2b_hex("12899c8312213a123321321321543344")
                    crypted_blob = blobtext[10:]
                    if repr(steam.verify_message(key, crypted_blob)) :
                        plaintext = steam.aes_decrypt(key, IV, crypted_blob[4:-4])
                        blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
                        blob_len = len(plaintext) - 16 - blob_len
                        blob = steam.blob_unserialize(plaintext[16:-blob_len])
                        #print(blob)
                        #print(binascii.b2a_hex(blob["\x01\x00\x00\x00"]))
                        #print(binascii.b2a_hex(userblob['\x05\x00\x00\x00'][username]['\x01\x00\x00\x00']))
                        if blob["\x01\x00\x00\x00"] == userblob['\x05\x00\x00\x00'][username]['\x01\x00\x00\x00'] :
                            userblob['\x05\x00\x00\x00'][username]['\x03\x00\x00\x00'] = blob["\x02\x00\x00\x00"]
                            userblob['\x05\x00\x00\x00'][username]['\x04\x00\x00\x00'] = blob["\x04\x00\x00\x00"]
                            userblob['\x05\x00\x00\x00'][username]['\x05\x00\x00\x00'] = blob["\x03\x00\x00\x00"]
                            if (os.path.isfile("files/users/" + username + ".py")) :
                                with open("files/users/" + username + ".py", 'w') as userblobfile :
                                    userblobfile.write("user_registry = ")
                                    userblobfile.write(str(userblob))                              
                                log.info(clientid + "Secret question changed for: " + username)
                                self.socket.send("\x00")
                            else :
                                log.warn(clientid + "SADB file error for: " + username)
                                self.socket.send("\x01")
                        else :
                            log.warn(clientid + "Secret question change failed for: " + username)
                            self.socket.send("\x01")
                    else :
                        log.warn(clientid + "Secret question change failed for: " + username)
                        self.socket.send("\x01")
                elif binascii.b2a_hex(command[0:1]) == "12" : #Change email
                    log.info(clientid + "Change email")
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    data1_len = int(data1_len, 16) * 2
                    userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    ticket_len = int(ticket_len, 16) * 2
                    ticket = ticket_full[2:ticket_len + 2]
                    postticketdata = ticket_full[2 + ticket_len + 4:]
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    iv = binascii.a2b_hex(postticketdata[0:32])
                    encdata_len = int(postticketdata[36:40], 16) * 2
                    encdata = postticketdata[40:40 + encdata_len]
                    decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
                    decodedmessage = binascii.a2b_hex(decodedmessage)
                    username_len_new = struct.unpack("<H", decodedmessage[0:2])
                    username_len_new = (2 + username_len_new[0]) * 2
                    header = username_len_new + 8
                    blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
                    blob_len = (blob_len[0])
                    blob = (decodedmessage[header:header + blob_len])
                    padding_byte = blob[-1:]
                    padding_int = struct.unpack(">B", padding_byte)
                    new_email_addr = blob[:-padding_int[0]]
                    new_email_addr = new_email_addr + "\x00"
                    
                    userblob = {}
                    execdict_new = {}
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    personalsalt = userblob['\x05\x00\x00\x00'][username]['\x02\x00\x00\x00']
                    new_email = {}
                    new_email = {"\x0b\x00\x00\x00": new_email_addr}
                    userblob.update(new_email)
                    with open("files/users/" + username + ".py", 'w') as g:
                        g.write("user_registry = " + str(userblob))
                    secretkey = {'\x05\x00\x00\x00'}
                    def without_keys(d, keys) :
                        return {x: d[x] for x in d if x not in keys}
                    execdict_new = without_keys(userblob, secretkey)
                    #print(userblob)
                    #print(execdict_new)
                    blob = steam.blob_serialize(execdict_new)
                    #print(blob)
                    bloblen = len(blob)
                    log.debug("Blob length: " + str(bloblen))
                    innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                    #innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                    innerIV = userIV
                    blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                    blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                    blob_signature = steam.sign_message(innerkey, blob_encrypted)
                    blob_encrypted_len = 10 + len(blob_encrypted) + 20
                    blob_encrypted = struct.pack(">L", blob_encrypted_len) + "\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted
                    ticket = ticket + blob_encrypted
                    ticket_signed = ticket + steam.sign_message(innerkey, ticket)
                    self.socket.send("\x00" + blob_encrypted + blob_signature)
                elif binascii.b2a_hex(command[0:1]) == "05" : #Subscribe
                    log.info(clientid + "Subscribe to package")
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    data1_len = int(data1_len, 16) * 2
                    userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    ticket_len = int(ticket_len, 16) * 2
                    ticket = ticket_full[2:ticket_len + 2]
                    postticketdata = ticket_full[2 + ticket_len + 4:]
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    iv = binascii.a2b_hex(postticketdata[0:32])
                    encdata_len = int(postticketdata[36:40], 16) * 2
                    encdata = postticketdata[40:40 + encdata_len]
                    decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
                    decodedmessage = binascii.a2b_hex(decodedmessage)
                    username_len_new = struct.unpack("<H", decodedmessage[0:2])
                    username_len_new = (2 + username_len_new[0]) * 2
                    header = username_len_new + 8
                    blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
                    blob_len = (blob_len[0])
                    blob = (decodedmessage[header:header + blob_len])
                    padding_byte = blob[-1:]
                    padding_int = struct.unpack(">B", padding_byte)
                    blobnew = steam.blob_unserialize(decodedmessage[header:header + blob_len])
                    #------------------------------------------------------------------
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        execdict = {}
                        execdict_new = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        steamtime = steam.unixtime_to_steamtime(time.time())
                        new_sub = {blobnew["\x01\x00\x00\x00"]: {'\x01\x00\x00\x00': steamtime, '\x02\x00\x00\x00': '\x00\x00\x00\x00\x00\x00\x00\x00', '\x03\x00\x00\x00': '\x00\x00', '\x05\x00\x00\x00': '\x00', '\x06\x00\x00\x00': '\x1f\x00'}}
                        new_buy = {blobnew["\x01\x00\x00\x00"]: blobnew["\x02\x00\x00\x00"]}
                        receipt_dict = {}
                        receipt_dict_01 = {}
                        receipt_sub_dict = {}
                        subid = new_buy.keys()[0]
                        execdict["\x07\x00\x00\x00"].update(new_sub)
                        #pprint.pprint(new_sub)
                        #pprint.pprint(new_buy)
                        #pprint.pprint(subid)
                        if new_buy[subid]['\x02\x00\x00\x00']['\x01\x00\x00\x00'] == "WONCDKey\x00" or new_buy[subid]['\x02\x00\x00\x00']['\x01\x00\x00\x00'] == "ValveCDKey\x00" :
                            receipt_sub_dict["\x01\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x01\x00\x00\x00"]
                            receipt_sub_dict["\x02\x00\x00\x00"] = str(random.randint(11111111, 99999999)) + "\x00"
                            receipt_dict_01["\x01\x00\x00\x00"] = "\x06"
                            receipt_dict_01["\x02\x00\x00\x00"] = receipt_sub_dict
                            receipt_dict[subid] = receipt_dict_01
                        else :
                            receipt_sub_dict["\x01\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x01\x00\x00\x00"]
                            receipt_sub_dict["\x02\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x02\x00\x00\x00"][12:]
                            receipt_sub_dict["\x03\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x03\x00\x00\x00"]
                            receipt_sub_dict["\x07\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x07\x00\x00\x00"]
                            receipt_sub_dict["\x08\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x08\x00\x00\x00"]
                            receipt_sub_dict["\x09\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x09\x00\x00\x00"]
                            receipt_sub_dict["\x0a\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x0a\x00\x00\x00"]
                            receipt_sub_dict["\x0b\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x0b\x00\x00\x00"]
                            receipt_sub_dict["\x0c\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x0c\x00\x00\x00"]
                            receipt_sub_dict["\x0d\x00\x00\x00"] = str(random.randint(111111, 999999)) + "\x00"
                            receipt_sub_dict["\x0e\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x14\x00\x00\x00"]
                            receipt_sub_dict["\x0f\x00\x00\x00"] = new_buy[subid]["\x02\x00\x00\x00"]["\x15\x00\x00\x00"]
                            receipt_sub_dict["\x10\x00\x00\x00"] = datetime.datetime.now().strftime("%d/%m/%Y") + "\x00"
                            receipt_sub_dict["\x11\x00\x00\x00"] = datetime.datetime.now().strftime("%H:%M:%S") + "\x00"
                            receipt_sub_dict["\x12\x00\x00\x00"] = str(random.randint(11111111, 99999999)) + "\x00"
                            receipt_sub_dict["\x13\x00\x00\x00"] = "\x00\x00\x00\x00"
                            receipt_dict_01["\x01\x00\x00\x00"] = "\x05"
                            receipt_dict_01["\x02\x00\x00\x00"] = receipt_sub_dict
                            receipt_dict[subid] = receipt_dict_01
                        new_buy.clear()
                        execdict["\x0f\x00\x00\x00"].update(receipt_dict)
                        with open("files/users/" + username + ".py", 'w') as g:
                            g.write("user_registry = " + str(execdict))
                        secretkey = {'\x05\x00\x00\x00'}
                        def without_keys(d, keys) :
                            return {x: d[x] for x in d if x not in keys}
                        execdict_new = without_keys(execdict, secretkey)
                        #print(execdict)
                        #print(execdict_new)
                        blob = steam.blob_serialize(execdict_new)
                        #print(blob)
                        bloblen = len(blob)
                        log.debug("Blob length: " + str(bloblen))
                        innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                        blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                        blob_signature = steam.sign_message(innerkey, blob_encrypted)
                        blob_encrypted_len = 10 + len(blob_encrypted) + 20
                        blob_encrypted = struct.pack(">L", blob_encrypted_len) + "\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
                        self.socket.send("\x00" + blob_encrypted)
                elif binascii.b2a_hex(command[0:1]) == "09" : #Ticket Login
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    data1_len = int(data1_len, 16) * 2
                    userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    log.info(clientid + "Ticket login for: " + username)
                    ticket_len = int(ticket_len, 16) * 2
                    postticketdata = ticket_full[2 + ticket_len + 4:]
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    iv = binascii.a2b_hex(postticketdata[0:32])
                    encdata_len = int(postticketdata[36:40], 16) * 2
                    encdata = postticketdata[40:40 + encdata_len]
                    decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
                    #------------------------------------------------------------------
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        #self.socket.send("\x00")
                        # create login ticket
                        execdict = {}
                        execdict_new = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        for sub_dict in execdict:
                            if sub_dict == "\x07\x00\x00\x00":
                                for sub_sub_dict in execdict[sub_dict]:
                                    if execdict[sub_dict][sub_sub_dict]["\x03\x00\x00\x00"] == "\x00\x00":
                                        execdict[sub_dict][sub_sub_dict]["\x03\x00\x00\x00"] = "\x01\x00"
                                        execdict[sub_dict][sub_sub_dict]["\x05\x00\x00\x00"] = "\x01"
                                        execdict[sub_dict][sub_sub_dict]["\x06\x00\x00\x00"] = "\x00\x00"
                        with open("files/users/" + username + ".py", 'w') as g:
                            g.write("user_registry = " + str(execdict))
                        secretkey = {'\x05\x00\x00\x00'}
                        def without_keys(d, keys) :
                            return {x: d[x] for x in d if x not in keys}
                        execdict_new = without_keys(execdict, secretkey)
                        #print(execdict)
                        #print(execdict_new)
                        blob = steam.blob_serialize(execdict_new)
                        #print(blob)
                        bloblen = len(blob)
                        log.debug("Blob length: " + str(bloblen))
                        innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                        blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                        blob_signature = steam.sign_message(innerkey, blob_encrypted)
                        blob_encrypted_len = 10 + len(blob_encrypted) + 20
                        blob_encrypted = struct.pack(">L", blob_encrypted_len) + "\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
                        self.socket.send("\x00" + blob_encrypted)
                        
                        execdict = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        for sub_dict in execdict:
                            if sub_dict == "\x07\x00\x00\x00":
                                for sub_sub_dict in execdict[sub_dict]:
                                    if execdict[sub_dict][sub_sub_dict]["\x03\x00\x00\x00"] == "\x01\x00":
                                        #execdict[sub_dict][sub_sub_dict]["\x03\x00\x00\x00"] = "\x01\x00"
                                        execdict[sub_dict][sub_sub_dict]["\x05\x00\x00\x00"] = "\x00"
                                        #execdict[sub_dict][sub_sub_dict]["\x06\x00\x00\x00"] = "\x00\x00"
                        with open("files/users/" + username + ".py", 'w') as g:
                            g.write("user_registry = " + str(execdict))
                else :
                    log.debug(clientid + "Unknown command: " + binascii.b2a_hex(command[0:1])) #04 logoff
                    self.socket.send("\x01")
            elif len(command) == 1 :
                if command == "\x1d" or command == "\x1e" : #Check username - new user
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + "\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + "\x02\x01\x11"
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + "\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print(plaintext)
                    plainblob = steam.blob_unserialize(plaintext)
                    #print(plainblob)
                    username = plainblob['\x01\x00\x00\x00']
                    username_str = username.rstrip('\x00')
                    #print(len(username_str))
                    log.info(clientid + "New user: check username exists: " + username_str)
                    if (os.path.isfile("files/users/" + username_str + ".py")) :
                        log.warn(clientid + "New user: username already exists")
                        self.socket.send("\xff")#not working
                    else :
                        log.info(clientid + "New user: username not found")
                        self.socket.send("\x00")
                elif command == "\x22" : #Check email - new user
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + "\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + "\x02\x01\x11"
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + "\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print(plaintext)
                    plainblob = steam.blob_unserialize(plaintext)
                    #print(plainblob)
                    email = plainblob['\x01\x00\x00\x00']
                    email_str = email.rstrip('\x00')
                    #print(len(username_str))
                    log.info(clientid + "New user: check email exists: " + email_str)
                    email_exists = False
                    for file in os.listdir("files/users/"):
                        if file.endswith("py"):
                            with open("files/users/" + file, 'r') as f:
                                userblobstr = f.read()
                                userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                            email_addr = userblob['\x0b\x00\x00\x00']
                            if email_addr.rstrip('\x00') == email_str :
                                email_exists = True
                                break
                    if email_exists == True  :
                        log.warn(clientid + "New user: email already in use")
                        self.socket.send("\xff")#not working
                    else :
                        log.info(clientid + "New user: email ok to use")
                        self.socket.send("\x00")
                elif command == "\x01" : #New user
                    log.info(clientid + "New user: Create user")
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + "\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + "\x02\x01\x11"
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + "\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print(plaintext)
                    plainblob = steam.blob_unserialize(plaintext)
                    #print(plainblob)
                    
                    username = plainblob['\x01\x00\x00\x00']
                    username_str = username.rstrip('\x00')
                    
                    #invalid6 = {'\x06\x00\x00\x00'}
                    #def without_keys(d, keys) :
                    #    return {x: d[x] for x in d if x not in keys}
                    
                    #plainblob_fixed = without_keys(plainblob, invalid6)
                    
                    #dict6 = {}
                    #dict6 = {'\x06\x00\x00\x00': {username_str: {'\x01\x00\x00\x00': '\x10\x20\x30\x40\x00\x00\x00\x00', '\x02\x00\x00\x00': '\x00\x01', '\x03\x00\x00\x00': {}}}}
                    
                    #plainblob_fixed.update(dict6)
                    
                    newsteamid = os.urandom(4) + "\x00\x00\x00\x00" #generate random steamId
                    plainblob['\x06\x00\x00\x00'][username_str]['\x01\x00\x00\x00'] = newsteamid
                    
                    invalid7 = {'\x07\x00\x00\x00'}
                    def without_keys(d, keys) :
                        return {x: d[x] for x in d if x not in keys}
                    
                    plainblob_fixed = without_keys(plainblob, invalid7)
                    
                    dict7 = {}
                    dict7 = {'\x07\x00\x00\x00': {'\x00\x00\x00\x00': {'\x01\x00\x00\x00': '\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00', '\x02\x00\x00\x00': '\x00\x00\x00\x00\x00\x00\x00\x00', '\x03\x00\x00\x00': '\x01\x00', '\x05\x00\x00\x00': '\x00', '\x06\x00\x00\x00': '\x1f\x00'}}}
                    
                    plainblob_fixed.update(dict7)
                    
                    dictf = {}
                    dictf = {'\x0f\x00\x00\x00': {'\x00\x00\x00\x00': {'\x01\x00\x00\x00': '\x07', '\x02\x00\x00\x00': {}}}}
                    
                    plainblob_fixed.update(dictf)
                        
                    with open("files/users/" + username_str + ".py", 'w') as userblobfile :
                        userblobfile.write("user_registry = ")
                        userblobfile.write(str(plainblob_fixed))
                    
                    self.socket.send("\x00")
                elif command == "\x0e" :
                    log.info(clientid + "command: Lost password - username check")
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + "\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + "\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)
                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    print(plaintext)
                    blobdict = steam.blob_unserialize(plaintext)
                    print(blobdict)
                    usernamechk = blobdict['\x01\x00\x00\x00']
                    username_str = usernamechk.rstrip('\x00')
                    if os.path.isfile("files/users/" + username_str + ".py") :
                        self.socket.send("\x00")
                    else :
                        self.socket.send("\x01")
                elif command == "\x0f" :
                    log.info(clientid + "command: Lost password - reset")
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + "\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + "\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)
                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print(plaintext)
                    blobdict = steam.blob_unserialize(plaintext)
                    #print(blobdict)
                    usernamechk = blobdict['\x01\x00\x00\x00']
                    username_str = usernamechk.rstrip('\x00')
                    with open("files/users/" + username_str + ".py", 'r') as userblobfile:
                        userblobstr = userblobfile.read()
                        userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    #print(userblob)
                    personalsalt = userblob['\x05\x00\x00\x00'][username_str]['\x02\x00\x00\x00']
                    #print(personalsalt)
                    self.socket.send(personalsalt) #NEW SALT PER USER
                    reply2 = self.socket.recv_withlen()
                
                    RSAdata = reply2[2:130]
                    datalength = struct.unpack(">L", reply2[130:134])[0]
                    cryptedblob_signature = reply2[134:136]
                    cryptedblob_length = reply2[136:140]
                    cryptedblob_slack = reply2[140:144]
                    cryptedblob = reply2[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print steam.blob_unserialize(plaintext)
                    
                    
                elif command == "\x20" :
                    log.info(clientid + "command: Lost password - email check")
                elif command == "\x21" :
                    log.info(clientid + "command: Lost password - product check")
                else :
                    # This is cheating. I've just cut'n'pasted the hex from the network_key. FIXME
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + "\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + "\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print steam.blob_unserialize(plaintext)
                
                    self.socket.send("\x00")
            else :
                log.warning(clientid + "Invalid command length: " + str(len(command)))

        else :
            data = self.socket.recv(65535)
            log.warning(clientid + "Invalid command: " + binascii.b2a_hex(command[1:5]))
            log.warning(clientid + "Extra data:", binascii.b2a_hex(data))

        self.socket.close()
        log.info(clientid + "Disconnected from Auth Server")
